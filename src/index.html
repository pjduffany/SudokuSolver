<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Sudoku in WASM</title>
  <style>
    table {
      border-collapse: collapse;
      margin: 30px auto;
      border: 3px solid #222;
    }

    td {
      width: 2.2em;
      height: 2.2em;
      text-align: center;
      vertical-align: middle;
      font-size: 1.4em;
      font-family: monospace;
      border: 1px solid #aaa;
      background-color: #fff;
    }

    /* Highlight outer border of 3×3 boxes */
    td:nth-child(3), td:nth-child(6) {
      border-right: 3px solid #222;
    }

    tr:nth-child(3) td, tr:nth-child(6) td {
      border-bottom: 3px solid #222;
    }

    .given {
      background: #eef;
      font-weight: bold;
      color: #333;
    }

    .solved {
      background: #d9f9d9;
      color: #222;
    }

    .editable {
      background: #fff;
      color: #000;
    }

    .editable:focus {
      outline: 2px solid #66f;
    }

    .invalid {
      background: #fdd;
      border: 2px solid red;
    }
  </style>
</head>
<body>
<h1 style="text-align:center">Sudoku Solver</h1>
<div style="text-align: center; margin-top: 1em;">
  <label for="difficulty">Difficulty:</label>
  <select id="difficulty">
    <option value="30">Easy</option>
    <option value="45">Medium</option>
    <option value="55">Hard</option>
  </select>
  <button id="new">New Puzzle</button>
  <button id="solve">Solve Puzzle</button>
  <button id="play">Play</button>
</div>
<table id="grid"></table>
<script src="sudoku.js"></script>
<script>
  SudokuModule().then(mod => {
    const N = 9;
    const grid = document.getElementById("grid");
    // Allocate 81 ints (4 bytes each) in WASM memory
    let ptr = mod._malloc(81 * 4);
    let heap = new Int32Array(mod.HEAP32.buffer, ptr, 81);  // allocate once

    // build the HTML table
    for (let r = 0; r < N; r++) {
      const row = grid.insertRow();
      for (let c = 0; c < N; c++) {
        const cell = row.insertCell();
        cell.dataset.row = r;
        cell.dataset.col = c;
        cell.contentEditable = false;  // toggle this for user input
        cell.addEventListener("input", (e) => {
          const cell = e.target;
          const row = parseInt(cell.dataset.row, 10);
          const col = parseInt(cell.dataset.col, 10);
          const raw = cell.innerText.trim();
          const val = parseInt(raw, 10);

          // Sanitize: allow only 1–9, otherwise clear
          if (!/^[1-9]$/.test(raw)) {
            cell.innerText = "";
            heap[row * 9 + col] = 0;
            cell.classList.remove("invalid");
            return;
          }

          // Update heap
          heap[row * 9 + col] = val;

          // ✅ Check with C logic: row, col, box
          const isValid = mod._is_valid_buffer(ptr, row, col, val);

          if (isValid) {
            cell.classList.remove("invalid");
          } else {
            cell.classList.add("invalid");
          }
        });
      }
    }
    function renderGrid(heap, className = "", locked = true) {
      for (let idx = 0; idx < N * N; idx++) {
        const r = Math.floor(idx / N);
        const c = idx % N;
        const val = heap[idx];
        const cell = grid.rows[r].cells[c];
        cell.innerText = val || "";
        cell.className = val ? className : "";

        // Style classes
        if (val) {
          cell.className = className;
        } else {
          cell.className = locked ? "" : "editable";
        }

        // Control editability
        cell.contentEditable = !locked && !val;
      }
    }
    // hook up the “New Puzzle” button
    document.getElementById("new").onclick = () => {
      const difficulty = parseInt(document.getElementById("difficulty").value, 10);

      if (ptr !== null) mod._free(ptr);
      ptr = mod._malloc(81 * 4); // reallocate
      heap = new Int32Array(mod.HEAP32.buffer, ptr, 81); // ✅ refresh view
      mod._generate_puzzle(ptr, difficulty);
      renderGrid(heap, "given", true);
      document.getElementById("solve").disabled = false; // reenable the solve button
      document.getElementById("play").disabled = false; // reenable the solve button

    };
    // hook up the "Solve Puzzle" button
    document.getElementById("solve").onclick = () => {
      mod._fill_puzzle(ptr); // call into C to solve it (same flat buffer)
      renderGrid(heap, "solved");
      document.getElementById("solve").disabled = true; // disable to prevent multiple solves
      document.getElementById("play").disabled = true; // disable

    };
    document.getElementById("play").onclick = () => {
      //mod._fill_puzzle(ptr); // call into C to solve it (same flat buffer)
      renderGrid(heap, "given", false);
      document.getElementById("solve").disabled = false; // disable to prevent multiple solves

    };
    // generate one on load
    document.getElementById("new").click();
  });
</script>
</body>
</html>